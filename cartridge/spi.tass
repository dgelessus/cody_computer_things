; Copyright (C) 2025 dgelessus
; 
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <https://www.gnu.org/licenses/>.

; Some SPI functions that can be called from BASIC.
; Very unfinished - currently only has one function that checks whether a cartridge is present.

; VIA registers
via_iorb = $9f00 ; IO register B
via_iora = $9f01 ; IO register A
via_ddrb = $9f02 ; Data direction register B
via_acr = $9f0b ; Auxiliary control register
via_pcr = $9f0c ; Peripheral control register
via_ifr = $9f0d ; Interrupt flag register

screen_ram = $c400 ; Default base address of screen memory

; Zero page variables
* = 0

; BASIC program memory goes from $0200 up to $6500
; and is used roughly from the bottom up
; depending on the size of the currently loaded BASIC code.
; Thus, it's usually safe to put custom code/data here,
; as long as the BASIC program is not so large that it needs the entire program memory.
LOAD_POSITION = $6300
PERSISTENT_CODE_POSITION = $6400 ; decimal 25600
PERSISTENT_CODE_MAX = $6600

; Program header for Cody BASIC's loader (needs to be first).
* = 0
.word LOAD_POSITION ; Starting address
.word (LOAD_END - 1) ; Ending address

; Cody BASIC's loader will put the data at LOAD_POSITION.
.logical LOAD_POSITION
	ldx #0
_print_loop:
	lda BOOT_MESSAGE, x
	beq _print_done
	sta screen_ram, x
	inc x
	bra _print_loop
_print_done:
	
	; TODO Replace this with a robust loop based on the zero page variable JIFFIES
	lda #10
	ldx #0
	ldy #0
_idle_loop:
	inc y
	bne _idle_loop
	inc x
	bne _idle_loop
	dec a
	bne _idle_loop
	
	rts

BOOT_MESSAGE: .text format("SPI calls loaded. Call SYS %d etc.", JUMP_TABLE)

.cerror * > PERSISTENT_CODE_POSITION, format("Boot code too long: %#04x > %04x", *, PERSISTENT_CODE_POSITION)
* = PERSISTENT_CODE_POSITION

; Jump table header.
; Callers could use this for simple feature detection at runtime
; to check whether an entry actually exists before trying to use it.
JUMP_TABLE_HEADER:
	; First byte is rts so that nothing terrible happens if someone incorrectly tries to call the header.
	; This should also be considered a magic number/signature:
	; if the first byte is *not* rts,
	; then the header or the jump table doesn't have the format documented here.
	rts
	; Second byte is currently 0 and should be ignored for now.
	; It might be used in the future for extra metadata that is backwards-compatible
	; (i. e. that can be safely ignored by callers that don't expect or need it).
	.byte 0
	; Third byte is the number of jump table entries after this header.
	; This is a number of *entries*, not a number of bytes!
	.cerror (JUMP_TABLE_END - JUMP_TABLE) % 3 != 0, format("Jump table size must be a multiple of 3 bytes: %d %% 3 == %d", JUMP_TABLE_END - JUMP_TABLE, (JUMP_TABLE_END - JUMP_TABLE) % 3)
	.byte (JUMP_TABLE_END - JUMP_TABLE) / 3
	.cerror JUMP_TABLE - JUMP_TABLE_HEADER != 3, format("Jump table header must be exactly 3 bytes long, not %d bytes", JUMP_TABLE - JUMP_TABLE_HEADER)

; The actual jump table.
; A simple sequence of 3-byte entries.
JUMP_TABLE:
	jmp is_cartridge_present
	jmp set_up_expansion_port_for_cartridge
	jmp read_eeprom_address_size
	jmp end_spi_transaction
	jmp send_spi_byte
	jmp receive_spi_byte
JUMP_TABLE_END:

; Check whether the cartridge detect pins are connected or not.
; Loosely based on CARTCHECK from codybasic.asm.
; z flag: will be set iff no cartridge detected
; a: will be 0 iff no cartridge detected
; x: clobbered
; via_pcr: will be set to $00
; via_ifr: CA1/CA2 flags will be cleared
is_cartridge_present:
	; Cartridge detect works as follows:
	; CA2 is our output.
	; CA1 is our input,
	; pulled low through a resistor.
	; If the cartridge wishes to be detected,
	; it connects CA1 to CA2,
	; so that setting CA2 to high will also drive CA1 high.
	; If the cartridge does not wish to be detected or is not present,
	; setting CA2 high has no effect and CA1 will remain low.
	
	; Set PCR to:
	; CB2, CB1: don't care
	; CA2: low output
	; CA1: positive active edge interrupt
	lda #%000_0_110_1
	sta via_pcr
	
	; Read IRA to clear the CA1 interrupt flag
	; (and also CA2, though we don't care about that).
	lda via_iora
	
	; Set PCR to:
	; CB2, CB1: don't care
	; CA2: high output
	; CA1: positive active edge interrupt
	lda #%000_0_111_1
	sta via_pcr
	
	; Read interrupt flags (CA1 flag needed later).
	lda via_ifr
	
	; Clear the CA1 (and CA2) interrupt flag again.
	ldx via_iora
	
	; Reset PCR so CA2 stops outputting.
	ldx #$00
	stx via_pcr
	
	; Check whether the CA1 interrupt flag was set.
	and #%0_00_00_0_10
	
	rts

; Configure the VIA's port B
; (which is connected to the Cody Computer's expansion port)
; for communication with an SPI EEPROM on the cartridge.
; a: clobbered
; via_ddrb: configured/clobbered
set_up_expansion_port_for_cartridge:
	; Disable latching for IO port B.
	; Modify ACR:
	; T1, T2, SR: no change
	; PB: disable latching
	; PA: no change
	lda via_acr
	and #%11_1_111_0_1
	sta via_acr
	
	; Set input/output modes for port B:
	; PB0 (serial clock): output
	; PB1 (chip serial data in): output
	; PB2 (chip serial data out): input
	; PB3 (negated chip select): output
	; PB4 (address size): input
	; PB5-PB7 (unused): don't care
	lda #%000_01011
	sta via_ddrb
	
	; Intentionally continue into end_spi_transaction
	; to set all outputs to a known initial state.

; End any active SPI transaction by turning chip select off.
; Safe to call regardless of the current state of chip select.
; a: clobbered
end_spi_transaction:
	; PB0 (serial clock): low (don't really care, but is appropriate for start of next SPI transaction)
	; PB1 (chip serial data in): don't care
	; PB3 (negated chip select): high (off)
	lda #%1000
	sta via_iorb
	
	rts

; z flag: matches a
; a: will be 0 iff addresses are 16-bit, not 0 iff addresses are 24-bit
read_eeprom_address_size:
	lda via_iorb
	and #%10000
	rts

; Send a byte to the SPI device.
; This also starts an SPI transaction if one isn't already in progress,
; i. e. ensures that chip select is on.
; a: byte to send (clobbered)
; x: clobbered
; y: clobbered
send_spi_byte:
	; Initialize loop counter.
	ldy #8
	
_loop:
	; Shift next bit to send from a into c flag.
	rol a
	; Save remaining bits into x,
	; because a will be clobbered in the next steps.
	tax
	
	; Prepare outputs:
	; PB0 (serial clock): low
	; PB1 (chip serial data in): bit to send
	; PB3 (negated chip select): low (on)
	bcs _prepare_send_1
	lda #%000
	bra _prepared_send
_prepare_send_1:
	lda #%010
_prepared_send:
	
	; Set outputs.
	sta via_iorb
	
	; Pull clock high.
	ora #%001
	sta via_iorb
	
	; Retrieve remaining bits to send,
	; previously saved in x.
	txa
	
	; Loop until counter reaches 0.
	dec y
	bne _loop
	
	rts

; Receive a byte from the SPI device.
; This also starts an SPI transaction if one isn't already in progress,
; i. e. ensures that chip select is on.
; a: will contain the received byte
; x: clobbered
; y: clobbered
receive_spi_byte:
	; Initialize output byte.
	lda #0
	; Initialize loop counter.
	ldy #8
	
_loop:
	; Save already read bits into x,
	; because a will be clobbered in the next steps.
	tax
	
	; Prepare outputs:
	; PB0 (serial clock): low
	; PB1 (chip serial data in): don't care
	; PB3 (negated chip select): low (on)
	stz via_iorb
	
	; Pull clock high.
	lda #%001
	sta via_iorb
	
	; Read PB2 (chip serial data out).
	lda #%00100
	bit via_iorb
	bne _received_1
	
	; Received a 0 bit.
	txa
	clc
	bra _received_done
_received_1:
	; Received a 1 bit.
	txa
	sec
_received_done:
	; Shift received bit from c flag into a.
	rol a
	
	; Loop until counter reaches 0.
	dec y
	bne _loop
	
	rts

.cerror * > PERSISTENT_CODE_MAX, format("Persistent code too long: %04x > %04x", *, PERSISTENT_CODE_MAX)

LOAD_END:
.endlogical
