; Copyright (C) 2025 dgelessus
; 
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <https://www.gnu.org/licenses/>.

; Some SPI functions that can be called from BASIC.
; Very unfinished - currently only has one function that checks whether a cartridge is present.

; VIA registers
via_iora = $9f01 ; IO register A
via_pcr = $9f0c ; Peripheral control register
via_ifr = $9f0d ; Interrupt flag register

screen_ram = $c400 ; Default base address of screen memory

; Zero page variables
* = 0

; BASIC program memory goes from $0200 up to $6500
; and is used roughly from the bottom up
; depending on the size of the currently loaded BASIC code.
; Thus, it's usually safe to put custom code/data here,
; as long as the BASIC program is not so large that it needs the entire program memory.
LOAD_POSITION = $6300
PERSISTENT_CODE_POSITION = $6400 ; decimal 25600
PERSISTENT_CODE_MAX = $6600

; Program header for Cody BASIC's loader (needs to be first).
* = 0
.word LOAD_POSITION ; Starting address
.word (LOAD_END - 1) ; Ending address

; Cody BASIC's loader will put the data at LOAD_POSITION.
.logical LOAD_POSITION
	ldx #0
_print_loop:
	lda BOOT_MESSAGE, x
	beq _print_done
	sta screen_ram, x
	inc x
	bra _print_loop
_print_done:
	
	; TODO Replace this with a robust loop based on the zero page variable JIFFIES
	lda #10
	ldx #0
	ldy #0
_idle_loop:
	inc y
	bne _idle_loop
	inc x
	bne _idle_loop
	dec a
	bne _idle_loop
	
	rts

BOOT_MESSAGE: .text format("SPI call loaded. Call SYS %d", is_cartridge_present)

.cerror * > PERSISTENT_CODE_POSITION, format("Boot code too long: %#04x > %04x", *, PERSISTENT_CODE_POSITION)
* = PERSISTENT_CODE_POSITION

; Check whether the cartridge detect pins are connected or not.
; Loosely based on CARTCHECK from codybasic.asm.
; z flag: will be set iff no cartridge detected
; a: will be 0 iff no cartridge detected
; x: clobbered
; via_pcr: will be set to $00
; via_ifr: CA1/CA2 flags will be cleared
is_cartridge_present:
	; Cartridge detect works as follows:
	; CA2 is our output.
	; CA1 is our input,
	; pulled low through a resistor.
	; If the cartridge wishes to be detected,
	; it connects CA1 to CA2,
	; so that setting CA2 to high will also drive CA1 high.
	; If the cartridge does not wish to be detected or is not present,
	; setting CA2 high has no effect and CA1 will remain low.
	
	; Set PCR to:
	; CB2, CB1: don't care
	; CA2: low output
	; CA1: positive active edge interrupt
	lda #%000_0_110_1
	sta via_pcr
	
	; Read IRA to clear the CA1 interrupt flag
	; (and also CA2, though we don't care about that).
	lda via_iora
	
	; Set PCR to:
	; CB2, CB1: don't care
	; CA2: high output
	; CA1: positive active edge interrupt
	lda #%000_0_111_1
	sta via_pcr
	
	; Read interrupt flags (CA1 flag needed later).
	lda via_ifr
	
	; Clear the CA1 (and CA2) interrupt flag again.
	ldx via_iora
	
	; Reset PCR so CA2 stops outputting.
	ldx #$00
	stx via_pcr
	
	; Check whether the CA1 interrupt flag was set.
	and #%0_00_00_0_10
	
	rts

.cerror * > PERSISTENT_CODE_MAX, format("Persistent code too long: %04x > %04x", *, PERSISTENT_CODE_MAX)

LOAD_END:
.endlogical
